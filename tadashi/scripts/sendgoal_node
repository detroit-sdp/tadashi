#!/usr/bin/env python

import rospy
import actionlib
import socket
import time
import tadashi_helpers as helpers
from const import *
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import Odometry
from geometry_msgs.msg import PoseWithCovariance, Twist, Pose, Point, Quaternion

class Client:
	def __init__(self):
		rospy.init_node('send_goal', anonymous=True)
		self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
		self.client.wait_for_server()

		self.positiontracker = rospy.Subscriber('odom', Odometry, self.position_callback)
		self.position = Point()
		self.orientation = Quaternion()

	def position_callback(self, msg):
		self.position = msg.pose.pose.position
		self.orientation = msg.pose.pose.orientation
		print(self.position)

	def send_goal(self, goal, returngoal):
		self.client.send_goal(goal)
		self.client.wait_for_result()

		if self.client.get_result():
			rospy.loginfo('Goal met')
			raw_input('Press [ENTER] to return to base')
			returngoal.target_pose.header.stamp = rospy.Time.now()
			self.client.send_goal(returngoal)
			self.client.wait_for_result()

			if self.client.get_result():
				rospy.loginfo('Succesfully returned to base')
			else:
				rospy.logerr('Base not reached')
		else:
			rospy.logerr('Goal not reached')

	def get_goal(self, room):
		point = ROOMS[room]

		target = MoveBaseGoal()
		target.target_pose.header.frame_id = 'base_link'
		target.target_pose.header.stamp = rospy.Time.now()
		target.target_pose.pose.position.x, target.target_pose.pose.position.y = helpers.pointstovector((self.position.x,
																					self.position.y), point)

		if ROOMS[room] == 'F'
			target.target_pose.pose.orientation.z = 0
			target.target_pose.pose.orientation.w = 1
		elif ROOMS[room] == 'R':
			target.target_pose.pose.orientation.z = 0.7071
			target.target_pose.pose.orientation.w = 0.7071
		elif ROOMS[room] == 'B':
			target.target_pose.pose.orientation.z = 1
			target.target_pose.pose.orientation.w = 0
		elif ROOMS[room] == 'L':
			target.target_pose.pose.orientation.z = -0.7071
			target.target_pose.pose.orientation.w = 0.7071

		return target
	
	def getbasereturn(self):
		turn = MoveBaseGoal()
		turn.target_pose.header.frame_id = 'base_link'
		turn.target_pose.header.stamp = rospy.Time.now()
		turn.target_pose.pose.position.x = 0
		turn.target_pose.pose.position.y = 0
		turn.target_pose.pose.orientation.z = 0
		turn.target_pose.pose.orientation.w = 1
		self.client.send_goal(turn)
		self.client.wait_for_result()

		returngoal = MoveBaseGoal()
		returngoal.target_pose.header.frame_id = 'base_link'
		returngoal.target_pose.header.stamp = rospy.Time.now()
		returngoal.target_pose.pose.position.x, returngoal.target_pose.pose.position.y = helpers.pointstovector((self.position.x,
																		self.position.y), ROOMS['BASE'])
		return returngoal

	def receive_goal(self):
		localIP = ''

		localPort = 20001
		bufferSize = 1024

		UDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
		UDPServerSocket.bind((localIP, localPort))
		UDPServerSocket.settimeout(None)

		print('UDP server up and listening')

		while(True):
			bytesAddressPair = UDPServerSocket.recvfrom(bufferSize)

			commands = helpers.splitstringbychar(bytesAddressPair[0], ' ')
			address = bytesAddressPair[1]

			rospy.loginfo('Message from Client:{}'.format(bytesAddressPair[0]))
			rospy.loginfo('Client IP Address:{}'.format(address))

			command = commands[0]
			args = commands[1:]

			if not (command.upper() in COMMANDS):
				rospy.logerr('Command not recognised')
				continue

			target = get_goal(int(args[0]))
			self.send_goal(target)

			rospy.loginfo('Goal met and returned to base')


if __name__ == '__main__':
	try:
		sndr = Client()
		sndr.receive_goal()
		rospy.spin()
	except rospy.ROSInterruptException:
		rospy.logerr('Program interrupted before completion')