#!/usr/bin/env python

import rospy
import actionlib
import socket
import time
import tadashi_helpers as helpers
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Pose, PoseWithCovarianceStamped, Twist

class Client:
    def __init__(self):
        rospy.init_node('send_goal', anonymous=True)
        self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.client.wait_for_server()

        # init_pose = rospy.Publisher('initialpose', PoseWithCovarianceStamped, queue_size=1)
        # initialPose = PoseWithCovarianceStamped()
        # initialPose.pose.pose.position.x = 0.0
        # initialPose.pose.pose.position.y = 0.0
        # intialPose.pose.orientation.w = 1.0
        # init_pose.publish(initialPose)
        base = PoseWithCovarianceStamped()
        base.pose.pose.position.x = 0.0
        base.pose.pose.position.y = 0.0

    def sendGoal(self, goal):
        self.client.send_goal(goal)
        self.client.wait_for_result()
        returngoal = self.base

        if self.client.get_result():
            rospy.loginfo('Goal met')
            raw_input('Press [ENTER] to return to base')
            self.client.send_goal(returngoal)
            self.client.wait_for_result()
        else:
            rospy.logerr('Goal not reached')

    def invert(self, goal):
        inverted = MoveBaseGoal()
        inverted.target_pose.header.frame_id = 'base_link'
        inverted.target_pose.header.stamp = rospy.Time.now()
        inverted.target_pose.pose.position.x = -1.0 * (goal.target_pose.pose.position.x)
        inverted.target_pose.pose.position.y = -1.0 * (goal.target_pose.pose.position.y)
        inverted.target_pose.pose.orientation.w = goal.target_pose.pose.orientation.w

        return inverted

    def coord2distance(self, (x, y)):
        # self.getpose
        # returnx = -1 * (currentx - x)
        # returny = -1 * (currenty - y)
        # return (returnx, returny)
        return None

    def receiveGoal(self):
        localIP = ''

        localPort = 20001
        bufferSize = 1024

        # msgFromServer = "Message received"
        # bytesToSend = str.encode(msgFromServer)

        UDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        UDPServerSocket.bind((localIP, localPort))
        UDPServerSocket.settimeout(None)

        print('UDP server up and listening')

        while(True):
            bytesAddressPair = UDPServerSocket.recvfrom(bufferSize)

            commands = helpers.splitstringbychar(bytesAddressPair[0], ' ')
            address = bytesAddressPair[1]

            rospy.loginfo('Message from Client:{}'.format(bytesAddressPair[0]))
            rospy.loginfo('Client IP Address:{}'.format(address))

            command = commands[0]
            args = commands[1:]

            if command.upper() != 'GOTO' or int(args[0]) > 3:
                rospy.logerr('Command not recognised')
                continue

            target = MoveBaseGoal()
            target.target_pose.header.frame_id = 'base_link'
            target.target_pose.header.stamp = rospy.Time.now()

            if int(args[0]) == 1:
                rospy.loginfo('Going to room 1')
                target.target_pose.pose.position.x = 0
                target.target_pose.pose.position.y = 0
                target.target_pose.pose.orientation.w = 0.732
            elif int(args[0]) == 2:
                rospy.loginfo('Going to room 2')
                target.target_pose.pose.position.x = 0
                target.target_pose.pose.position.y = 0
                target.target_pose.pose.orientation.w = 0.969
            elif int(args[0]) == 3:
                rospy.loginfo('Going to room 3')
                target.target_pose.pose.position.x = 0
                target.target_pose.pose.position.y = 0
                target.target_pose.pose.orientation.w = 1.0
        
            self.sendGoal(target)
            rospy.loginfo('Goal met and returned to base')

            # # address = (address[0], 20002)
            # UDPServerSocket.sendto(bytesToSend, address)


if __name__ == '__main__':
    try:
        sndr = Client()
        sndr.receiveGoal()
        rospy.spin()
    except rospy.ROSInterruptException:
        rospy.logerr('Program interrupted before completion')